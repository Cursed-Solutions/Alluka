{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Alluka A type based dependency injection framework for Python 3.9+. Usage For how to get started with this library, see the documentation . Installation You can install Alluka from PyPI using the following command in any Python 3.9 or above environment. python -m pip install -U alluka Contributing Before contributing you should read through the contributing guidelines and the code of conduct","title":"Home"},{"location":"#alluka","text":"A type based dependency injection framework for Python 3.9+.","title":"Alluka"},{"location":"#usage","text":"For how to get started with this library, see the documentation .","title":"Usage"},{"location":"#installation","text":"You can install Alluka from PyPI using the following command in any Python 3.9 or above environment. python -m pip install -U alluka","title":"Installation"},{"location":"#contributing","text":"Before contributing you should read through the contributing guidelines and the code of conduct","title":"Contributing"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased 0.1.1 - 2020-03-20 Fixed Regression around handling of \"signature-less\" builtin functions. A ValueError will no longer be raised in these cases. 0.1.0 - 2020-02-25 All of the 0.1.0 entries are relative to the feature set exposed while this was a part of Tanjun. Added Support for synchronous dependency injection (this comes with AsyncOnlyError ) Abstract interface for the client with limited functionality. call_with_di and call_with_async_di to alluka.abc.Context as a shorthand for executing a callback with that context. call_with_di , call_with_async_di , call_with_ctx and call_with_ctx_async methods to the injection client for executing callbacks with DI. Support for inferring the type of a parameter from its type hint when no type or callback is explicitly provided. Support for using typing.Annotated to declare parameter DI. This takes two forms: parameter: alluka.Inject[Type] to infer specifically a type dependency. parameter: typing.Annotated(Type, alluka.inject(type=.../callback=...)) . Changed Passed keyword arguments are now prioritised over dependency injection. Removed The public CallackDescriptor and TypeDescriptor classes as callbacks are now processed within the client and any necessary caching is kept internal.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#011-2020-03-20","text":"","title":"0.1.1 - 2020-03-20"},{"location":"changelog/#fixed","text":"Regression around handling of \"signature-less\" builtin functions. A ValueError will no longer be raised in these cases.","title":"Fixed"},{"location":"changelog/#010-2020-02-25","text":"All of the 0.1.0 entries are relative to the feature set exposed while this was a part of Tanjun.","title":"0.1.0 - 2020-02-25"},{"location":"changelog/#added","text":"Support for synchronous dependency injection (this comes with AsyncOnlyError ) Abstract interface for the client with limited functionality. call_with_di and call_with_async_di to alluka.abc.Context as a shorthand for executing a callback with that context. call_with_di , call_with_async_di , call_with_ctx and call_with_ctx_async methods to the injection client for executing callbacks with DI. Support for inferring the type of a parameter from its type hint when no type or callback is explicitly provided. Support for using typing.Annotated to declare parameter DI. This takes two forms: parameter: alluka.Inject[Type] to infer specifically a type dependency. parameter: typing.Annotated(Type, alluka.inject(type=.../callback=...)) .","title":"Added"},{"location":"changelog/#changed","text":"Passed keyword arguments are now prioritised over dependency injection.","title":"Changed"},{"location":"changelog/#removed","text":"The public CallackDescriptor and TypeDescriptor classes as callbacks are now processed within the client and any necessary caching is kept internal.","title":"Removed"},{"location":"usage/","text":"Usage Function injection This form of dependency injection works by injecting values for keyword arguments during callback execution based on the linked client. This is the main form of dependency injection implemented by Alluka. Declaring a function's injected dependencies There are two styles for declaring a function's injected dependencies in Alluka: Default descriptors def callback ( foo : Foo = alluka . inject ( type = Foo ) bar : BarResult = alluka . inject ( callback = bar_callback ) ) -> None : ... Assigning the result of alluka.inject to a parameter's default will declare it as requiring an injected type or callback. async def callback ( foo : Foo = alluka . inject () ) -> None : ... If neither type nor callback is passed to alluka.inject then a type dependency will be inferred from the parameter's annotation. Warning The type-hint will need to resolvable/accessible at runtime in the callback's module for it to be inferred (so it can't be hidden behind a typing.TYPE_CHECKING only import or using a type or operation that isn't implemented in the current python version). Type-hint metadata typing.Annotated style type-hint descriptors may be used to declare the injected dependencies for a function. def callback ( foo : typing . Annotated [ Foo , alluka . inject ( type = Foo )], bar : typing . Annotated [ BarResult , alluka . inject ( callback = bar_callback )] ) -> None : ... Where passing the default descriptors returned by alluka.inject to typing.Annotated lets you declare the type or callback dependency for an argument without effecting non-DI calls to the function (by leaving these parameters required). async def callback ( foo : alluka . Injected [ Foo ] ) -> None : ... And alluka.Injected provides a shorthand for using typing.Annotated to declare a type dependency. Note alluka.Injected can be safely passed to typing.Annotated as the first type argument or vice versa thanks to how Annotated handles nesting. Calling functions with dependency injection client : alluka . Client async def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = await client . call_with_async_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with async dependency injection alluka.abc.Client.call_with_async_di should be called with the function and any positional or keyword arguments to pass through alongside the the injected arguments. Note While both sync and async functions may be executed with call_with_async_di , you'll always have to await call_with_async_di to get the result of the call. client : alluka . Client def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = client . call_with_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with purely sync dependency injection alluka.abc.Client.call_with_di can be used with similar semantics to call_with_async_di for passed through arguments but this comes with the limitation that only sync functions may be used and any dependency on async callback dependencies will lead to alluka.AsyncOnlyError being raised. def foo ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = ctx . call_with_di ( other_callback , 542 , keyword_arg = \"meow\" ) Alternatively, alluka.abc.Context.call_with_di and alluka.abc.Context.call_with_async_di can be used to execute functions with dependency injection while preserving the current injection context. async def bar ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = await ctx . call_with_async_di ( other_callback , 123 , keyword_arg = \"ok\" ) Using the client Adding type dependencies client = ( alluka . Client () . set_type_dependency ( TypeA , type_a_impl ) . set_type_dependencu ( TypeB , type_b_impl ) ) For a type dependency to work, the linked client will have to have an implementation loaded for it. While right now the only way to load type dependencies is with the lower-level alluka.abc.Client.set_type_dependency method, more approaches and helpers will be added in the future as Alluka is further developed. Overriding callback dependencies client = alluka . Client () . set_callback_override ( callback , other_callback ) While (unlike type dependencies) callback dependencies can work on their own without being explicitly declared on the client unless they're relying on a type dependency themselves, they can still be overridden on a client level using alluka.abc.Client.set_callback_override . Generally speaking you should only ever override an injected callback with a callback which returns a compatible type but their signatures do not need to match and async callbacks can be overridden with sync with vice versa also working (although the latter will prevent callbacks from being used in an async context).","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#function-injection","text":"This form of dependency injection works by injecting values for keyword arguments during callback execution based on the linked client. This is the main form of dependency injection implemented by Alluka.","title":"Function injection"},{"location":"usage/#declaring-a-functions-injected-dependencies","text":"There are two styles for declaring a function's injected dependencies in Alluka:","title":"Declaring a function's injected dependencies"},{"location":"usage/#default-descriptors","text":"def callback ( foo : Foo = alluka . inject ( type = Foo ) bar : BarResult = alluka . inject ( callback = bar_callback ) ) -> None : ... Assigning the result of alluka.inject to a parameter's default will declare it as requiring an injected type or callback. async def callback ( foo : Foo = alluka . inject () ) -> None : ... If neither type nor callback is passed to alluka.inject then a type dependency will be inferred from the parameter's annotation. Warning The type-hint will need to resolvable/accessible at runtime in the callback's module for it to be inferred (so it can't be hidden behind a typing.TYPE_CHECKING only import or using a type or operation that isn't implemented in the current python version).","title":"Default descriptors"},{"location":"usage/#type-hint-metadata","text":"typing.Annotated style type-hint descriptors may be used to declare the injected dependencies for a function. def callback ( foo : typing . Annotated [ Foo , alluka . inject ( type = Foo )], bar : typing . Annotated [ BarResult , alluka . inject ( callback = bar_callback )] ) -> None : ... Where passing the default descriptors returned by alluka.inject to typing.Annotated lets you declare the type or callback dependency for an argument without effecting non-DI calls to the function (by leaving these parameters required). async def callback ( foo : alluka . Injected [ Foo ] ) -> None : ... And alluka.Injected provides a shorthand for using typing.Annotated to declare a type dependency. Note alluka.Injected can be safely passed to typing.Annotated as the first type argument or vice versa thanks to how Annotated handles nesting.","title":"Type-hint metadata"},{"location":"usage/#calling-functions-with-dependency-injection","text":"client : alluka . Client async def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = await client . call_with_async_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with async dependency injection alluka.abc.Client.call_with_async_di should be called with the function and any positional or keyword arguments to pass through alongside the the injected arguments. Note While both sync and async functions may be executed with call_with_async_di , you'll always have to await call_with_async_di to get the result of the call. client : alluka . Client def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = client . call_with_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with purely sync dependency injection alluka.abc.Client.call_with_di can be used with similar semantics to call_with_async_di for passed through arguments but this comes with the limitation that only sync functions may be used and any dependency on async callback dependencies will lead to alluka.AsyncOnlyError being raised. def foo ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = ctx . call_with_di ( other_callback , 542 , keyword_arg = \"meow\" ) Alternatively, alluka.abc.Context.call_with_di and alluka.abc.Context.call_with_async_di can be used to execute functions with dependency injection while preserving the current injection context. async def bar ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = await ctx . call_with_async_di ( other_callback , 123 , keyword_arg = \"ok\" )","title":"Calling functions with dependency injection"},{"location":"usage/#using-the-client","text":"","title":"Using the client"},{"location":"usage/#adding-type-dependencies","text":"client = ( alluka . Client () . set_type_dependency ( TypeA , type_a_impl ) . set_type_dependencu ( TypeB , type_b_impl ) ) For a type dependency to work, the linked client will have to have an implementation loaded for it. While right now the only way to load type dependencies is with the lower-level alluka.abc.Client.set_type_dependency method, more approaches and helpers will be added in the future as Alluka is further developed.","title":"Adding type dependencies"},{"location":"usage/#overriding-callback-dependencies","text":"client = alluka . Client () . set_callback_override ( callback , other_callback ) While (unlike type dependencies) callback dependencies can work on their own without being explicitly declared on the client unless they're relying on a type dependency themselves, they can still be overridden on a client level using alluka.abc.Client.set_callback_override . Generally speaking you should only ever override an injected callback with a callback which returns a compatible type but their signatures do not need to match and async callbacks can be overridden with sync with vice versa also working (although the latter will prevent callbacks from being used in an async context).","title":"Overriding callback dependencies"},{"location":"reference/","text":"alluka A type based dependency injection framework for Python 3.9+. Injected = typing . Annotated [ _T , InjectedTypes . TYPE ] module-attribute Type alias used to declare a keyword argument as requiring an injected type. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. Note This is a typing.Annotated alias and the behaviour for nested Annotated types may be found at the docs for it typing.Annotated . AllukaError Bases: Exception Base clases for the custom errors raised by Alluka. AsyncOnlyError Bases: AllukaError Error raised when trying to execute async DI in a sync context. AsyncSelfInjecting Bases: abc . AsyncSelfInjecting [ _CallbackSigT ] Class used to link a sync function to a client to make it self-injecting. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . AsyncSelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_async_self_injecting may be used: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __init__ ( / , client , callback ) Initialise a self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: abc . Client callback The callback to make self-injecting. This may be sync or async. TYPE: alluka.abc.CallbackSig RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally. BasicContext Bases: abc . Context Basic implementation of alluka.abc.Context . __init__ ( / , client ) Initialise a basic injection context. PARAMETER DESCRIPTION client The injection client this context is bound to. TYPE: abc . Client Client Bases: abc . Client Standard implementation of a dependency injection client. This is used to track type dependencies and execute callbacks. __init__ ( introspect_annotations = True ) Initialise an injector client. InjectedDescriptor Bases: typing . Generic [ _T ] Descriptor used to a declare keyword-argument as requiring an injected dependency. This is the type returned by alluka.inject . __init__ ( * , callback = None , type = None ) Initialise an injection default descriptor. Note If neither type or callback is provided, an injected type will be inferred from the argument's annotation. PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ abc . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately after the litarl union type is tried, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Optional [ _TypeT [ _T ]] DEFAULT: None RAISES DESCRIPTION ValueError If both callback and type are provided. MissingDependencyError Bases: AllukaError Error raised when a dependency couldn't be found. __init__ ( / , message , dependency_type ) Initialise a missing dependency error. PARAMETER DESCRIPTION message The error message. TYPE: str SelfInjecting Bases: abc . SelfInjecting [ _SyncCallbackT ] Class used to link a sync function to a client to make it self-injecting. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . SelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_self_injecting may be used: client = alluka . Client () @client . as_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __init__ ( / , client , callback ) Initialise a sync self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: abc . Client callback The callback to make self-injecting. TYPE: collections.abc.Callable RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally. inject ( * , callback = None , type = None ) Decare a keyword-argument as requiring an injected dependency. This may be assigned to an arugment's default value to declare injection or as a part of its Annotated metadata. Note If neither type nor callback is provided, an injected type will be inferred from the argument's annotation. Examples: async def callback ( # Here we require an implementation of the type `Component` to be # injected. injected_type : Component = alluka . inject ( type = Component ) # Here we inject an out-of-scope callback which itself is taking # advantage of type injectioallukan. callback_result : ResultT = alluka . inject ( callback = injected_callback ) ) -> None : raise NotImplementedError ... # where client is an `alluka.Client` instance. result = await client . call_with_async_di ( callback ) PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ abc . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Any DEFAULT: None RAISES DESCRIPTION ValueError If both type and callback are provided.","title":"alluka"},{"location":"reference/#alluka_1","text":"A type based dependency injection framework for Python 3.9+.","title":"alluka"},{"location":"reference/#alluka.Injected","text":"Type alias used to declare a keyword argument as requiring an injected type. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. Note This is a typing.Annotated alias and the behaviour for nested Annotated types may be found at the docs for it typing.Annotated .","title":"Injected"},{"location":"reference/#alluka.AllukaError","text":"Bases: Exception Base clases for the custom errors raised by Alluka.","title":"AllukaError"},{"location":"reference/#alluka.AsyncOnlyError","text":"Bases: AllukaError Error raised when trying to execute async DI in a sync context.","title":"AsyncOnlyError"},{"location":"reference/#alluka.AsyncSelfInjecting","text":"Bases: abc . AsyncSelfInjecting [ _CallbackSigT ] Class used to link a sync function to a client to make it self-injecting. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . AsyncSelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_async_self_injecting may be used: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"AsyncSelfInjecting"},{"location":"reference/#alluka._self_injecting.AsyncSelfInjecting.__init__","text":"Initialise a self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: abc . Client callback The callback to make self-injecting. This may be sync or async. TYPE: alluka.abc.CallbackSig RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally.","title":"__init__()"},{"location":"reference/#alluka.BasicContext","text":"Bases: abc . Context Basic implementation of alluka.abc.Context .","title":"BasicContext"},{"location":"reference/#alluka._client.BasicContext.__init__","text":"Initialise a basic injection context. PARAMETER DESCRIPTION client The injection client this context is bound to. TYPE: abc . Client","title":"__init__()"},{"location":"reference/#alluka.Client","text":"Bases: abc . Client Standard implementation of a dependency injection client. This is used to track type dependencies and execute callbacks.","title":"Client"},{"location":"reference/#alluka._client.Client.__init__","text":"Initialise an injector client.","title":"__init__()"},{"location":"reference/#alluka.InjectedDescriptor","text":"Bases: typing . Generic [ _T ] Descriptor used to a declare keyword-argument as requiring an injected dependency. This is the type returned by alluka.inject .","title":"InjectedDescriptor"},{"location":"reference/#alluka._types.InjectedDescriptor.__init__","text":"Initialise an injection default descriptor. Note If neither type or callback is provided, an injected type will be inferred from the argument's annotation. PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ abc . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately after the litarl union type is tried, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Optional [ _TypeT [ _T ]] DEFAULT: None RAISES DESCRIPTION ValueError If both callback and type are provided.","title":"__init__()"},{"location":"reference/#alluka.MissingDependencyError","text":"Bases: AllukaError Error raised when a dependency couldn't be found.","title":"MissingDependencyError"},{"location":"reference/#alluka._errors.MissingDependencyError.__init__","text":"Initialise a missing dependency error. PARAMETER DESCRIPTION message The error message. TYPE: str","title":"__init__()"},{"location":"reference/#alluka.SelfInjecting","text":"Bases: abc . SelfInjecting [ _SyncCallbackT ] Class used to link a sync function to a client to make it self-injecting. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . SelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_self_injecting may be used: client = alluka . Client () @client . as_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"SelfInjecting"},{"location":"reference/#alluka._self_injecting.SelfInjecting.__init__","text":"Initialise a sync self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: abc . Client callback The callback to make self-injecting. TYPE: collections.abc.Callable RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally.","title":"__init__()"},{"location":"reference/#alluka.inject","text":"Decare a keyword-argument as requiring an injected dependency. This may be assigned to an arugment's default value to declare injection or as a part of its Annotated metadata. Note If neither type nor callback is provided, an injected type will be inferred from the argument's annotation. Examples: async def callback ( # Here we require an implementation of the type `Component` to be # injected. injected_type : Component = alluka . inject ( type = Component ) # Here we inject an out-of-scope callback which itself is taking # advantage of type injectioallukan. callback_result : ResultT = alluka . inject ( callback = injected_callback ) ) -> None : raise NotImplementedError ... # where client is an `alluka.Client` instance. result = await client . call_with_async_di ( callback ) PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ abc . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Any DEFAULT: None RAISES DESCRIPTION ValueError If both type and callback are provided.","title":"inject()"},{"location":"reference/abc/","text":"alluka.abc Alluka's abstract interfaces. CallbackSig = typing . Union [ collections . Callable [ Ellipsis , collections . Coroutine [ typing . Any , typing . Any , _T ]], collections . Callable [ Ellipsis , _T ]] module-attribute Type-hint of a injector callback. Note Dependency dependency injection is recursively supported, meaning that the keyword arguments for a dependency callback may also ask for dependencies themselves. This may either be a sync or asyc function with dependency injection being available for the callback's keyword arguments but dynamically returning either a coroutine or raw value may lead to errors. Dependent on the context positional arguments may also be proivded. UNDEFINED : typing . Final [ Undefined ] = Undefined () module-attribute Singleton value used within dependency injection to indicate that a value is undefined. AsyncSelfInjecting Bases: abc . ABC , typing . Generic [ _CallbackT ] Interface of a class used to make an async self-injecting callback. Examples: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __call__ ( * args , ** kwargs ) async Call this with the provided arguments and any injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback alongside injected arguments. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. callback () The callback this wraps. Client Abstract interface of a dependency injection client. as_async_self_injecting ( / , callback ) Link a function to a client to make it self-injecting. PARAMETER DESCRIPTION callback The callback to make self-injecting. This may be sync or async. TYPE: CallbackSig RETURNS DESCRIPTION AsyncSelfInjecting The async self-injecting callback. as_self_injecting ( / , callback ) Link a sync function to a client to make it self-injecting. Note This uses sync dependency injection and therefore will lead to errors if any of the callback's dependencies are async. PARAMETER DESCRIPTION callback The callback to make self-injecting. This must be sync. TYPE: collections.abc.Callable RETURNS DESCRIPTION SelfInjecting The self-injecting callback. call_with_async_di ( callback , * args , ** kwargs ) async Call a function with async dependency injection. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async. call_with_ctx ( ctx , callback , * args , ** kwargs ) Call a function with an existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async. call_with_ctx_async ( ctx , callback , * args , ** kwargs ) async Asynchronously call a function with a pre-existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. call_with_di ( callback , * args , ** kwargs ) Call a function with sync dependency injection. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async. get_callback_override ( / , callback ) Get the override for a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to get the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION CallbackSig[_T] | None The override if found, else None . get_type_dependency ( / , type_ ) Get the implementation for an injected type. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] RETURNS DESCRIPTION _T | Undefined The resolved type if found, else UNDEFINED . remove_callback_override ( / , callback ) Remove a callback override. PARAMETER DESCRIPTION callback The injected callback to remove the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If no override is found for the callback. remove_type_dependency ( / , type_ ) Remove a type dependency. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ typing . Any ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If type is not registered. set_callback_override ( / , callback , override ) Override a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to override. TYPE: CallbackSig [ _T ] override The callback to use instead. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining. set_type_dependency ( / , type_ , value ) Set a callback to be called to resolve a injected type. PARAMETER DESCRIPTION type_ The type of the dependency to add an implementation for. TYPE: type [ _OtherT ] value The value of the dependency. TYPE: _OtherT RETURNS DESCRIPTION Self The client instance to allow chaining. Context Bases: abc . ABC Abstract interface of an injection context. cache_result ( / , callback , value ) Cache the result of a callback within the scope of this context. PARAMETER DESCRIPTION callback The callback to cache the result of. TYPE: CallbackSig [ _T ] value The value to cache. TYPE: _T call_with_async_di ( callback , * args , ** kwargs ) async Asynchronously call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. call_with_di ( callback , * args , ** kwargs ) Call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async. get_cached_result ( / , callback ) Get the cached result of a callback. PARAMETER DESCRIPTION callback The callback to get the cached result of. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION _T | Undefined The cached result of the callback, or UNDEFINED if the callback has not been cached within this context or caching isn't implemented. get_type_dependency ( / , type_ ) Get the implementation for an injected type. Note Unlike Client.get_type_dependency , this method may also return context specific implementations of a type. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] RETURNS DESCRIPTION _T | Undefined The resolved type if found, else UNDEFINED . injection_client () Injection client this context is bound to. SelfInjecting Bases: abc . ABC , typing . Generic [ _SyncCallbackT ] Interface of a class used to make a self-injecting callback. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: client = alluka . Client () @client . as_self_injecting def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __call__ ( * args , ** kwargs ) Call this callback with the provided arguments + injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async. callback () The callback this wraps. Undefined Class/type of UNDEFINED .","title":"alluka.abc"},{"location":"reference/abc/#allukaabc","text":"Alluka's abstract interfaces.","title":"alluka.abc"},{"location":"reference/abc/#alluka.abc.CallbackSig","text":"Type-hint of a injector callback. Note Dependency dependency injection is recursively supported, meaning that the keyword arguments for a dependency callback may also ask for dependencies themselves. This may either be a sync or asyc function with dependency injection being available for the callback's keyword arguments but dynamically returning either a coroutine or raw value may lead to errors. Dependent on the context positional arguments may also be proivded.","title":"CallbackSig"},{"location":"reference/abc/#alluka.abc.UNDEFINED","text":"Singleton value used within dependency injection to indicate that a value is undefined.","title":"UNDEFINED"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting","text":"Bases: abc . ABC , typing . Generic [ _CallbackT ] Interface of a class used to make an async self-injecting callback. Examples: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"AsyncSelfInjecting"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.__call__","text":"Call this with the provided arguments and any injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback alongside injected arguments. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client.","title":"__call__()"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.callback","text":"The callback this wraps.","title":"callback()"},{"location":"reference/abc/#alluka.abc.Client","text":"Abstract interface of a dependency injection client.","title":"Client"},{"location":"reference/abc/#alluka.abc.Client.as_async_self_injecting","text":"Link a function to a client to make it self-injecting. PARAMETER DESCRIPTION callback The callback to make self-injecting. This may be sync or async. TYPE: CallbackSig RETURNS DESCRIPTION AsyncSelfInjecting The async self-injecting callback.","title":"as_async_self_injecting()"},{"location":"reference/abc/#alluka.abc.Client.as_self_injecting","text":"Link a sync function to a client to make it self-injecting. Note This uses sync dependency injection and therefore will lead to errors if any of the callback's dependencies are async. PARAMETER DESCRIPTION callback The callback to make self-injecting. This must be sync. TYPE: collections.abc.Callable RETURNS DESCRIPTION SelfInjecting The self-injecting callback.","title":"as_self_injecting()"},{"location":"reference/abc/#alluka.abc.Client.call_with_async_di","text":"Call a function with async dependency injection. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_async_di()"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx","text":"Call a function with an existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_ctx()"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx_async","text":"Asynchronously call a function with a pre-existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client.","title":"call_with_ctx_async()"},{"location":"reference/abc/#alluka.abc.Client.call_with_di","text":"Call a function with sync dependency injection. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_di()"},{"location":"reference/abc/#alluka.abc.Client.get_callback_override","text":"Get the override for a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to get the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION CallbackSig[_T] | None The override if found, else None .","title":"get_callback_override()"},{"location":"reference/abc/#alluka.abc.Client.get_type_dependency","text":"Get the implementation for an injected type. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] RETURNS DESCRIPTION _T | Undefined The resolved type if found, else UNDEFINED .","title":"get_type_dependency()"},{"location":"reference/abc/#alluka.abc.Client.remove_callback_override","text":"Remove a callback override. PARAMETER DESCRIPTION callback The injected callback to remove the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If no override is found for the callback.","title":"remove_callback_override()"},{"location":"reference/abc/#alluka.abc.Client.remove_type_dependency","text":"Remove a type dependency. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ typing . Any ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If type is not registered.","title":"remove_type_dependency()"},{"location":"reference/abc/#alluka.abc.Client.set_callback_override","text":"Override a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to override. TYPE: CallbackSig [ _T ] override The callback to use instead. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining.","title":"set_callback_override()"},{"location":"reference/abc/#alluka.abc.Client.set_type_dependency","text":"Set a callback to be called to resolve a injected type. PARAMETER DESCRIPTION type_ The type of the dependency to add an implementation for. TYPE: type [ _OtherT ] value The value of the dependency. TYPE: _OtherT RETURNS DESCRIPTION Self The client instance to allow chaining.","title":"set_type_dependency()"},{"location":"reference/abc/#alluka.abc.Context","text":"Bases: abc . ABC Abstract interface of an injection context.","title":"Context"},{"location":"reference/abc/#alluka.abc.Context.cache_result","text":"Cache the result of a callback within the scope of this context. PARAMETER DESCRIPTION callback The callback to cache the result of. TYPE: CallbackSig [ _T ] value The value to cache. TYPE: _T","title":"cache_result()"},{"location":"reference/abc/#alluka.abc.Context.call_with_async_di","text":"Asynchronously call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client.","title":"call_with_async_di()"},{"location":"reference/abc/#alluka.abc.Context.call_with_di","text":"Call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_di()"},{"location":"reference/abc/#alluka.abc.Context.get_cached_result","text":"Get the cached result of a callback. PARAMETER DESCRIPTION callback The callback to get the cached result of. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION _T | Undefined The cached result of the callback, or UNDEFINED if the callback has not been cached within this context or caching isn't implemented.","title":"get_cached_result()"},{"location":"reference/abc/#alluka.abc.Context.get_type_dependency","text":"Get the implementation for an injected type. Note Unlike Client.get_type_dependency , this method may also return context specific implementations of a type. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] RETURNS DESCRIPTION _T | Undefined The resolved type if found, else UNDEFINED .","title":"get_type_dependency()"},{"location":"reference/abc/#alluka.abc.Context.injection_client","text":"Injection client this context is bound to.","title":"injection_client()"},{"location":"reference/abc/#alluka.abc.SelfInjecting","text":"Bases: abc . ABC , typing . Generic [ _SyncCallbackT ] Interface of a class used to make a self-injecting callback. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: client = alluka . Client () @client . as_self_injecting def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"SelfInjecting"},{"location":"reference/abc/#alluka.abc.SelfInjecting.__call__","text":"Call this callback with the provided arguments + injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka.MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka.AsyncOnlyError If the callback or any of its callback dependencies are async.","title":"__call__()"},{"location":"reference/abc/#alluka.abc.SelfInjecting.callback","text":"The callback this wraps.","title":"callback()"},{"location":"reference/abc/#alluka.abc.Undefined","text":"Class/type of UNDEFINED .","title":"Undefined"}]}