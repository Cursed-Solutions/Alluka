{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Alluka","text":"<p>A type based dependency injection framework for Python 3.9+.</p>"},{"location":"#usage","title":"Usage","text":"<p>For how to get started with this library, see the documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install Alluka from PyPI using the following command in any Python 3.9 or above environment.</p> <pre><code>python -m pip install -U alluka\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Before contributing you should read through the contributing guidelines and the code of conduct.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#013-2022-11-12","title":"0.1.3 - 2022-11-12","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>alluka.abc.Client</code> is now set as a type dependency by default.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Renamed <code>AsyncOnlyError</code> to <code>SyncOnlyError</code> (<code>AsyncOnlyError</code> has been kept as a   deprecated alias).</li> <li>Relaxed typing around DI for async callbacks to allow for returning a union of   <code>Coroutine[Any, Any, T] | T</code>.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Don't error on async callbacks which return a coroutine after being awaited   during DI when assertions are enabled.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>The project metadata dunder attributes from alluka.   importlib.metadata should be used to get this metadata instead.</li> </ul>"},{"location":"changelog/#012-2022-07-06","title":"0.1.2 - 2022-07-06","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>The optional <code>introspect_annotations</code> parameter for <code>alluka.Client.__init__</code>   is now keyword only.</li> <li><code>tanjun.abc.Client</code> is now a real <code>abc.ABC</code>.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>alluka.abc.Undefined</code> and <code>alluka.abc.UNDEFINED</code> for removal in <code>v0.2.0</code> as    these will no-longer be used.</li> <li><code>get_type_dependency</code> and <code>get_cached_result</code> returning <code>UNDEFINED</code> as the   default when no default is passed will be replaced by a <code>KeyError</code> raise in   <code>v0.2.0</code>.</li> </ul>"},{"location":"changelog/#011-2022-03-20","title":"0.1.1 - 2022-03-20","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Regression around handling of \"signature-less\" builtin functions.   A ValueError will no longer be raised in these cases.</li> </ul>"},{"location":"changelog/#010-2022-02-25","title":"0.1.0 - 2022-02-25","text":"<p>All of the <code>0.1.0</code> entries are relative to the feature set exposed while this was a part of Tanjun.</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for synchronous dependency injection (this comes with <code>SyncOnlyError</code>)</li> <li>Abstract interface for the client with limited functionality.</li> <li><code>call_with_di</code> and <code>call_with_async_di</code> to <code>alluka.abc.Context</code> as a shorthand for   executing a callback with that context.</li> <li><code>call_with_di</code>, <code>call_with_async_di</code>, <code>call_with_ctx</code> and <code>call_with_ctx_async</code>   methods to the injection client for executing callbacks with DI.</li> <li>Support for inferring the type of a parameter from its type hint   when no <code>type</code> or <code>callback</code> is explicitly provided.</li> <li>Support for using <code>typing.Annotated</code> to declare parameter DI. This takes two forms:</li> <li><code>parameter: alluka.Inject[Type]</code> to infer specifically a type dependency.</li> <li><code>parameter: typing.Annotated(Type, alluka.inject(type=.../callback=...))</code>.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Passed keyword arguments are now prioritised over dependency injection.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>The public <code>CallackDescriptor</code> and <code>TypeDescriptor</code> classes as callbacks   are now processed within the client and any necessary caching is kept internal.</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#function-injection","title":"Function injection","text":"<p>This form of dependency injection works by injecting values for keyword arguments during callback execution based on the linked client. This is the main form of dependency injection implemented by Alluka.</p>"},{"location":"usage/#declaring-a-functions-injected-dependencies","title":"Declaring a function's injected dependencies","text":"<p>There are two styles for declaring a function's injected dependencies in Alluka:</p>"},{"location":"usage/#default-descriptors","title":"Default descriptors","text":"<pre><code>def callback(\n    foo: Foo = alluka.inject(type=Foo)\n    bar: BarResult = alluka.inject(callback=bar_callback)\n) -&gt; None:\n    ...\n</code></pre> <p>Assigning the result of alluka.inject to a parameter's default will declare it as requiring an injected type or callback.</p> <pre><code>async def callback(\n    foo: Foo = alluka.inject()\n) -&gt; None:\n    ...\n</code></pre> <p>If neither <code>type</code> nor <code>callback</code> is passed to alluka.inject then a type dependency will be inferred from the parameter's annotation.</p> <p>Warning</p> <p>The type-hint will need to resolvable/accessible at runtime in the callback's module for it to be inferred (so it can't be hidden behind a typing.TYPE_CHECKING only import or using a type or operation that isn't implemented in the current python version).</p>"},{"location":"usage/#type-hint-metadata","title":"Type-hint metadata","text":"<p>typing.Annotated style type-hint descriptors may be used to declare the injected dependencies for a function.</p> <pre><code>def callback(\n    foo: typing.Annotated[Foo, alluka.inject(type=Foo)],\n    bar: typing.Annotated[BarResult, alluka.inject(callback=bar_callback)]\n) -&gt; None:\n    ...\n</code></pre> <p>Where passing the default descriptors returned by alluka.inject to typing.Annotated lets you declare the type or callback dependency for an argument without effecting non-DI calls to the function (by leaving these parameters required).</p> <pre><code>async def callback(\n    foo: alluka.Injected[Foo]\n) -&gt; None:\n    ...\n</code></pre> <p>And alluka.Injected provides a shorthand for using typing.Annotated to declare a type dependency.</p> <p>Note</p> <p>alluka.Injected can be safely passed to typing.Annotated as the first type argument or vice versa thanks to how Annotated handles nesting.</p>"},{"location":"usage/#calling-functions-with-dependency-injection","title":"Calling functions with dependency injection","text":"<pre><code>client: alluka.Client\n\nasync def callback(\n    argument: int,\n    /,\n    injected: alluka.Injected[Foo],\n    keyword_arg: str,\n) -&gt; int:\n    ...\n\n...\n\nresult = await client.call_with_async_di(callback, 123, keyword_arg=\"ok\")\n</code></pre> <p>To execute a function with async dependency injection alluka.abc.Client.call_with_async_di should be called with the function and any positional or keyword arguments to pass through alongside the the injected arguments.</p> <p>Note</p> <p>While both sync and async functions may be executed with <code>call_with_async_di</code>, you'll always have to await <code>call_with_async_di</code> to get the result of the call.</p> <pre><code>client: alluka.Client\n\ndef callback(\n    argument: int,\n    /,\n    injected: alluka.Injected[Foo],\n    keyword_arg: str,\n) -&gt; int:\n    ...\n\n...\n\nresult = client.call_with_di(callback, 123, keyword_arg=\"ok\")\n</code></pre> <p>To execute a function with purely sync dependency injection alluka.abc.Client.call_with_di can be used with similar semantics to <code>call_with_async_di</code> for passed through arguments but this comes with the limitation that only sync functions may be used and any dependency on async callback dependencies will lead to alluka.SyncOnlyError being raised.</p> <pre><code>def foo(ctx: alluka.Inject[alluka.abc.Context]) -&gt; None:\n    result = ctx.call_with_di(other_callback, 542, keyword_arg=\"meow\")\n</code></pre> <p>Alternatively, alluka.abc.Context.call_with_di and alluka.abc.Context.call_with_async_di can be used to execute functions with dependency injection while preserving the current injection context.</p> <pre><code>async def bar(ctx: alluka.Inject[alluka.abc.Context]) -&gt; None:\n    result = await ctx.call_with_async_di(other_callback, 123, keyword_arg=\"ok\")\n</code></pre>"},{"location":"usage/#using-the-client","title":"Using the client","text":""},{"location":"usage/#adding-type-dependencies","title":"Adding type dependencies","text":"<pre><code>client = (\n    alluka.Client()\n    .set_type_dependency(TypeA, type_a_impl)\n    .set_type_dependencu(TypeB, type_b_impl)\n)\n</code></pre> <p>For a type dependency to work, the linked client will have to have an implementation loaded for it. While right now the only way to load type dependencies is with the lower-level alluka.abc.Client.set_type_dependency method, more approaches and helpers will be added in the future as Alluka is further developed.</p>"},{"location":"usage/#overriding-callback-dependencies","title":"Overriding callback dependencies","text":"<pre><code>client = alluka.Client().set_callback_override(callback, other_callback)\n</code></pre> <p>While (unlike type dependencies) callback dependencies can work on their own without being explicitly declared on the client unless they're relying on a type dependency themselves, they can still be overridden on a client level using alluka.abc.Client.set_callback_override.</p> <p>Generally speaking you should only ever override an injected callback with a callback which returns a compatible type but their signatures do not need to match and async callbacks can be overridden with sync with vice versa also working (although the latter will prevent callbacks from being used in an async context).</p>"},{"location":"reference/","title":"alluka","text":"<p>A type based dependency injection framework for Python 3.9+.</p>"},{"location":"reference/#alluka.Injected","title":"Injected  <code>module-attribute</code>","text":"<pre><code>Injected = typing.Annotated[_T, InjectedTypes.TYPE]\n</code></pre> <p>Type alias used to declare a keyword argument as requiring an injected type.</p> <p>If a union (e.g. <code>typing.Union[A, B]</code>, <code>A | B</code>, <code>typing.Optional[A]</code>) is passed then each type in the union will be tried separately rather than the literal type, allowing for resolving <code>A | B</code> to the value set by <code>set_type_dependency(B, ...)</code>.</p> <p>If a union has <code>None</code> as one of its types (including <code>Optional[T]</code>) then <code>None</code> will be passed for the parameter if none of the types could be resolved using the linked client.</p> <p>Note</p> <p>This is a typing.Annotated alias and the behaviour for nested Annotated types may be found at the docs for it typing.Annotated.</p>"},{"location":"reference/#alluka.AllukaError","title":"AllukaError","text":"<p>         Bases: <code>Exception</code></p> <p>Base class for the custom errors raised by Alluka.</p>"},{"location":"reference/#alluka.AsyncSelfInjecting","title":"AsyncSelfInjecting","text":"<p>         Bases: <code>alluka.AsyncSelfInjecting[_CallbackSigT]</code></p> <p>Class used to link a sync function to a client to make it self-injecting.</p> <p>Examples:</p> <pre><code>async def callback(database: Database = alluka.inject(type=Database)) -&gt; None:\n    await database.do_something()\n...\n\nclient = alluka.Client()\ninjecting_callback = alluka.AsyncSelfInjecting(callback, client)\nawait injecting_callback()\n</code></pre> <p>Alternatively alluka.abc.Client.as_async_self_injecting may be used:</p> <pre><code>client = alluka.Client()\n\n@client.as_async_self_injecting\nasync def callback(database: Database = alluka.inject(type=Database)) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/#alluka._self_injecting.AsyncSelfInjecting.__init__","title":"__init__","text":"<pre><code>__init__(client, callback)\n</code></pre> <p>Initialise a self injecting callback.</p> PARAMETER DESCRIPTION <code>client</code> <p>The injection client to use to resolve dependencies.</p> <p> TYPE: <code>alluka.Client</code> </p> <code>callback</code> <p>The callback to make self-injecting.</p> <p>This may be sync or async.</p> <p> TYPE: <code>alluka.abc.CallbackSig</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>callback</code> has any injected arguments which can only be passed positionally.</p>"},{"location":"reference/#alluka.BasicContext","title":"BasicContext","text":"<p>         Bases: <code>alluka.Context</code></p> <p>Basic implementation of alluka.abc.Context.</p>"},{"location":"reference/#alluka._client.BasicContext.__init__","title":"__init__","text":"<pre><code>__init__(client)\n</code></pre> <p>Initialise a basic injection context.</p> PARAMETER DESCRIPTION <code>client</code> <p>The injection client this context is bound to.</p> <p> TYPE: <code>alluka.Client</code> </p>"},{"location":"reference/#alluka.Client","title":"Client","text":"<p>         Bases: <code>alluka.Client</code></p> <p>Standard implementation of a dependency injection client.</p> <p>This is used to track type dependencies and execute callbacks.</p>"},{"location":"reference/#alluka._client.Client.__init__","title":"__init__","text":"<pre><code>__init__(*, introspect_annotations=True)\n</code></pre> <p>Initialise an injector client.</p>"},{"location":"reference/#alluka.InjectedDescriptor","title":"InjectedDescriptor","text":"<p>         Bases: <code>typing.Generic[_T]</code></p> <p>Descriptor used to a declare keyword-argument as requiring an injected dependency.</p> <p>This is the type returned by alluka.inject.</p>"},{"location":"reference/#alluka._types.InjectedDescriptor.__init__","title":"__init__","text":"<pre><code>__init__(*, callback=None, type=None)\n</code></pre> <p>Initialise an injection default descriptor.</p> <p>Note</p> <p>If neither <code>type</code> or <code>callback</code> is provided, an injected type will be inferred from the argument's annotation.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to use to resolve the dependency.</p> <p>If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override.</p> <p> TYPE: <code>typing.Optional[alluka.CallbackSig[_T]]</code> DEFAULT: <code>None</code> </p> <code>type</code> <p>The type of the dependency to resolve.</p> <p>If a union (e.g. <code>typing.Union[A, B]</code>, <code>A | B</code>, <code>typing.Optional[A]</code>) is passed for <code>type</code> then each type in the union will be tried separately after the litarl union type is tried, allowing for resolving <code>A | B</code> to the value set by <code>set_type_dependency(B, ...)</code>.</p> <p>If a union has <code>None</code> as one of its types (including <code>Optional[T]</code>) then <code>None</code> will be passed for the parameter if none of the types could be resolved using the linked client.</p> <p> TYPE: <code>typing.Optional[_TypeT[_T]]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If both <code>callback</code> and <code>type</code> are provided.</p>"},{"location":"reference/#alluka.MissingDependencyError","title":"MissingDependencyError","text":"<p>         Bases: <code>AllukaError</code></p> <p>Error raised when a dependency couldn't be found.</p>"},{"location":"reference/#alluka._errors.MissingDependencyError.__init__","title":"__init__","text":"<pre><code>__init__(message, dependency_type)\n</code></pre> <p>Initialise a missing dependency error.</p> PARAMETER DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/#alluka.SelfInjecting","title":"SelfInjecting","text":"<p>         Bases: <code>alluka.SelfInjecting[_SyncCallbackT]</code></p> <p>Class used to link a sync function to a client to make it self-injecting.</p> <p>Note</p> <p>This executes the callback synchronously and therefore will error if any of the callback's dependencies are async.</p> <p>Examples:</p> <pre><code>async def callback(database: Database = alluka.inject(type=Database)) -&gt; None:\n    await database.do_something()\n...\n\nclient = alluka.Client()\ninjecting_callback = alluka.SelfInjecting(callback, client)\nawait injecting_callback()\n</code></pre> <p>Alternatively alluka.abc.Client.as_self_injecting may be used:</p> <pre><code>client = alluka.Client()\n\n@client.as_self_injecting\nasync def callback(database: Database = alluka.inject(type=Database)) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/#alluka._self_injecting.SelfInjecting.__init__","title":"__init__","text":"<pre><code>__init__(client, callback)\n</code></pre> <p>Initialise a sync self injecting callback.</p> PARAMETER DESCRIPTION <code>client</code> <p>The injection client to use to resolve dependencies.</p> <p> TYPE: <code>alluka.Client</code> </p> <code>callback</code> <p>The callback to make self-injecting.</p> <p> TYPE: <code>collections.abc.Callable</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>callback</code> has any injected arguments which can only be passed positionally.</p>"},{"location":"reference/#alluka.SyncOnlyError","title":"SyncOnlyError","text":"<p>         Bases: <code>AllukaError</code></p> <p>Error raised when trying to execute async DI in a sync context.</p>"},{"location":"reference/#alluka.inject","title":"inject","text":"<pre><code>inject(*, callback=None, type=None)\n</code></pre> <p>Decare a keyword-argument as requiring an injected dependency.</p> <p>This may be assigned to an arugment's default value to declare injection or as a part of its Annotated metadata.</p> <p>Note</p> <p>If neither <code>type</code> nor <code>callback</code> is provided, an injected type will be inferred from the argument's annotation.</p> <p>Examples:</p> <pre><code>async def callback(\n    # Here we require an implementation of the type `Component` to be\n    # injected.\n    injected_type: Component = alluka.inject(type=Component)\n    # Here we inject an out-of-scope callback which itself is taking\n    # advantage of type injectioallukan.\n    callback_result: ResultT = alluka.inject(callback=injected_callback)\n) -&gt; None:\n    raise NotImplementedError\n\n...\n# where client is an `alluka.Client` instance.\nresult = await client.call_with_async_di(callback)\n</code></pre> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to use to resolve the dependency.</p> <p>If this callback has no type dependencies then this will still work without an injection context but this can be overridden using <code>alluka.abc.Client.set_callback_override</code>.</p> <p> TYPE: <code>typing.Optional[alluka.CallbackSig[_T]]</code> DEFAULT: <code>None</code> </p> <code>type</code> <p>The type of the dependency to resolve.</p> <p>If a union (e.g. <code>typing.Union[A, B]</code>, <code>A | B</code>, <code>typing.Optional[A]</code>) is passed for <code>type</code> then each type in the union will be tried separately rather than the literal type, allowing for resolving <code>A | B</code> to the value set by <code>set_type_dependency(B, ...)</code>.</p> <p>If a union has <code>None</code> as one of its types (including <code>Optional[T]</code>) then <code>None</code> will be passed for the parameter if none of the types could be resolved using the linked client.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If both <code>type</code> and <code>callback</code> are provided.</p>"},{"location":"reference/abc/","title":"alluka.abc","text":"<p>Alluka's abstract interfaces.</p>"},{"location":"reference/abc/#alluka.abc.CallbackSig","title":"CallbackSig  <code>module-attribute</code>","text":"<pre><code>CallbackSig = collections.Callable[Ellipsis, typing.Union[_CoroT[_T], _T]]\n</code></pre> <p>Type-hint of a injector callback.</p> <p>Note</p> <p>Dependency dependency injection is recursively supported, meaning that the keyword arguments for a dependency callback may also ask for dependencies themselves.</p> <p>This may either be a sync or asyc function with dependency injection being available for the callback's keyword arguments but dynamically returning either a coroutine or raw value may lead to errors.</p> <p>Dependent on the context positional arguments may also be proivded.</p>"},{"location":"reference/abc/#alluka.abc.UNDEFINED","title":"UNDEFINED  <code>module-attribute</code>","text":"<pre><code>UNDEFINED: typing.Final[Undefined] = Undefined()\n</code></pre> <p>Deprecated singleton value used to indicate that a value is undefined</p> <p>deprecated</p> <p>This will be removedin <code>v0.2.0</code>.</p>"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting","title":"AsyncSelfInjecting","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_CallbackT]</code></p> <p>Interface of a class used to make an async self-injecting callback.</p> <p>Examples:</p> <pre><code>client = alluka.Client()\n\n@client.as_async_self_injecting\nasync def callback(database: Database = alluka.inject(type=Database)) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.callback","title":"callback  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>callback: _CallbackT\n</code></pre> <p>The callback this wraps.</p>"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.__call__","title":"__call__  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Call this with the provided arguments and any injected arguments.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback alongside injected arguments.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The callback's result.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p>"},{"location":"reference/abc/#alluka.abc.Client","title":"Client","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract interface of a dependency injection client.</p>"},{"location":"reference/abc/#alluka.abc.Client.as_async_self_injecting","title":"as_async_self_injecting  <code>abstractmethod</code>","text":"<pre><code>as_async_self_injecting(callback)\n</code></pre> <p>Link a function to a client to make it self-injecting.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to make self-injecting.</p> <p>This may be sync or async.</p> <p> TYPE: <code>CallbackSig</code> </p> RETURNS DESCRIPTION <code>AsyncSelfInjecting</code> <p>The async self-injecting callback.</p>"},{"location":"reference/abc/#alluka.abc.Client.as_self_injecting","title":"as_self_injecting  <code>abstractmethod</code>","text":"<pre><code>as_self_injecting(callback)\n</code></pre> <p>Link a sync function to a client to make it self-injecting.</p> <p>Note</p> <p>This uses sync dependency injection and therefore will lead to errors if any of the callback's dependencies are async.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to make self-injecting.</p> <p>This must be sync.</p> <p> TYPE: <code>collections.abc.Callable</code> </p> RETURNS DESCRIPTION <code>SelfInjecting</code> <p>The self-injecting callback.</p>"},{"location":"reference/abc/#alluka.abc.Client.call_with_async_di","title":"call_with_async_di  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>call_with_async_di(callback, *args, **kwargs)\n</code></pre> <p>Call a function with async dependency injection.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to call.</p> <p>This may be sync or async.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The result of the callback.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p> <code>alluka.SyncOnlyError</code> <p>If the callback or any of its callback dependencies are async.</p>"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx","title":"call_with_ctx  <code>abstractmethod</code>","text":"<pre><code>call_with_ctx(ctx, callback, *args, **kwargs)\n</code></pre> <p>Call a function with an existing DI context.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The DI context to call the callback with.</p> <p>This will be used for scoped type injection.</p> <p> TYPE: <code>Context</code> </p> <code>callback</code> <p>The callback to call.</p> <p>This must be sync.</p> <p> TYPE: <code>collections.Callable[..., _T]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The result of the callback.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p> <code>alluka.SyncOnlyError</code> <p>If the callback or any of its callback dependencies are async.</p>"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx_async","title":"call_with_ctx_async  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>call_with_ctx_async(ctx, callback, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with a pre-existing DI context.</p> PARAMETER DESCRIPTION <code>ctx</code> <p>The DI context to call the callback with.</p> <p>This will be used for scoped type injection.</p> <p> TYPE: <code>Context</code> </p> <code>callback</code> <p>The callback to call.</p> <p>This may be sync or async.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The result of the callback.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p>"},{"location":"reference/abc/#alluka.abc.Client.call_with_di","title":"call_with_di  <code>abstractmethod</code>","text":"<pre><code>call_with_di(callback, *args, **kwargs)\n</code></pre> <p>Call a function with sync dependency injection.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to call.</p> <p>This must be sync.</p> <p> TYPE: <code>collections.Callable[..., _T]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The result of the callback.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p> <code>alluka.SyncOnlyError</code> <p>If the callback or any of its callback dependencies are async.</p>"},{"location":"reference/abc/#alluka.abc.Client.get_callback_override","title":"get_callback_override  <code>abstractmethod</code>","text":"<pre><code>get_callback_override(callback)\n</code></pre> <p>Get the override for a specific injected callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The injected callback to get the override for.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> RETURNS DESCRIPTION <code>CallbackSig[_T] | None</code> <p>The override if found, else None.</p>"},{"location":"reference/abc/#alluka.abc.Client.get_type_dependency","title":"get_type_dependency  <code>abstractmethod</code>","text":"<pre><code>get_type_dependency(type_, /, *, default=UNDEFINED)\n</code></pre> <p>Get the implementation for an injected type.</p> <p>deprecated</p> <p>Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in <code>v0.2.0</code>.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The associated type.</p> <p> TYPE: <code>type[_T]</code> </p> <code>default</code> <p>The default value to return if the type is not implemented.</p> <p> TYPE: <code>_UndefinedOr[_DefaultT]</code> DEFAULT: <code>UNDEFINED</code> </p> RETURNS DESCRIPTION <code>_T | _DefaultT | alluka.abc.UNDEFINED</code> <p>The resolved type if found.</p> <p>If the type isn't implemented then the value of <code>default</code> will be returned if it is provided, else alluka.abc.UNDEFINED.</p>"},{"location":"reference/abc/#alluka.abc.Client.remove_callback_override","title":"remove_callback_override  <code>abstractmethod</code>","text":"<pre><code>remove_callback_override(callback)\n</code></pre> <p>Remove a callback override.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The injected callback to remove the override for.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If no override is found for the callback.</p>"},{"location":"reference/abc/#alluka.abc.Client.remove_type_dependency","title":"remove_type_dependency  <code>abstractmethod</code>","text":"<pre><code>remove_type_dependency(type_)\n</code></pre> <p>Remove a type dependency.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The associated type.</p> <p> TYPE: <code>type[typing.Any]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If <code>type</code> is not registered.</p>"},{"location":"reference/abc/#alluka.abc.Client.set_callback_override","title":"set_callback_override  <code>abstractmethod</code>","text":"<pre><code>set_callback_override(callback, override)\n</code></pre> <p>Override a specific injected callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The injected callback to override.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> <code>override</code> <p>The callback to use instead.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p>"},{"location":"reference/abc/#alluka.abc.Client.set_type_dependency","title":"set_type_dependency  <code>abstractmethod</code>","text":"<pre><code>set_type_dependency(type_, value)\n</code></pre> <p>Set a callback to be called to resolve a injected type.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The type of the dependency to add an implementation for.</p> <p> TYPE: <code>type[_T]</code> </p> <code>value</code> <p>The value of the dependency.</p> <p> TYPE: <code>_T</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The client instance to allow chaining.</p>"},{"location":"reference/abc/#alluka.abc.Context","title":"Context","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Abstract interface of an injection context.</p>"},{"location":"reference/abc/#alluka.abc.Context.injection_client","title":"injection_client  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>injection_client: Client\n</code></pre> <p>Injection client this context is bound to.</p>"},{"location":"reference/abc/#alluka.abc.Context.cache_result","title":"cache_result  <code>abstractmethod</code>","text":"<pre><code>cache_result(callback, value)\n</code></pre> <p>Cache the result of a callback within the scope of this context.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to cache the result of.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> <code>value</code> <p>The value to cache.</p> <p> TYPE: <code>_T</code> </p>"},{"location":"reference/abc/#alluka.abc.Context.call_with_async_di","title":"call_with_async_di  <code>async</code> <code>abstractmethod</code>","text":"<pre><code>call_with_async_di(callback, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with the current DI context.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to call.</p> <p>This may be sync or async.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The result of the callback.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p>"},{"location":"reference/abc/#alluka.abc.Context.call_with_di","title":"call_with_di  <code>abstractmethod</code>","text":"<pre><code>call_with_di(callback, *args, **kwargs)\n</code></pre> <p>Call a function with the current DI context.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to call.</p> <p>This must be sync.</p> <p> TYPE: <code>collections.Callable[..., _T]</code> </p> <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The result of the callback.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p> <code>alluka.SyncOnlyError</code> <p>If the callback or any of its callback dependencies are async.</p>"},{"location":"reference/abc/#alluka.abc.Context.get_cached_result","title":"get_cached_result  <code>abstractmethod</code>","text":"<pre><code>get_cached_result(callback, /, *, default=UNDEFINED)\n</code></pre> <p>Get the cached result of a callback.</p> <p>deprecated</p> <p>Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in <code>v0.2.0</code>.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to get the cached result of.</p> <p> TYPE: <code>CallbackSig[_T]</code> </p> <code>default</code> <p>The default value to return if the callback is not cached.</p> <p> TYPE: <code>_UndefinedOr[_DefaultT]</code> DEFAULT: <code>UNDEFINED</code> </p> RETURNS DESCRIPTION <code>_T | _DefaultT | alluka.abc.UNDEFINED</code> <p>The cached result of the callback if found.</p> <p>If the callback's result hasn't been cached or caching isn't implementing then this will return the value of <code>default</code> if it is provided, else alluka.abc.UNDEFINED.</p>"},{"location":"reference/abc/#alluka.abc.Context.get_type_dependency","title":"get_type_dependency  <code>abstractmethod</code>","text":"<pre><code>get_type_dependency(type_, /, *, default=UNDEFINED)\n</code></pre> <p>Get the implementation for an injected type.</p> <p>Unlike Client.get_type_dependency, this method may also return context specific implementations of a type.</p> <p>deprecated</p> <p>Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in <code>v0.2.0</code>.</p> PARAMETER DESCRIPTION <code>type_</code> <p>The associated type.</p> <p> TYPE: <code>type[_T]</code> </p> <code>default</code> <p>The default value to return if the type is not implemented.</p> <p> TYPE: <code>_UndefinedOr[_DefaultT]</code> DEFAULT: <code>UNDEFINED</code> </p> RETURNS DESCRIPTION <code>_T | _DefaultT | alluka.abc.UNDEFINED</code> <p>The resolved type if found.</p> <p>If the type isn't implemented then the value of <code>default</code> will be returned if it is provided, else alluka.abc.UNDEFINED.</p>"},{"location":"reference/abc/#alluka.abc.SelfInjecting","title":"SelfInjecting","text":"<p>         Bases: <code>abc.ABC</code>, <code>typing.Generic[_SyncCallbackT]</code></p> <p>Interface of a class used to make a self-injecting callback.</p> <p>Note</p> <p>This executes the callback synchronously and therefore will error if any of the callback's dependencies are async.</p> <p>Examples:</p> <pre><code>client = alluka.Client()\n\n@client.as_self_injecting\ndef callback(database: Database = alluka.inject(type=Database)) -&gt; None:\n    ...\n</code></pre>"},{"location":"reference/abc/#alluka.abc.SelfInjecting.callback","title":"callback  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>callback: _SyncCallbackT\n</code></pre> <p>The callback this wraps.</p>"},{"location":"reference/abc/#alluka.abc.SelfInjecting.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Call this callback with the provided arguments + injected arguments.</p> PARAMETER DESCRIPTION <code>*args</code> <p>Positional arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the callback.</p> <p> TYPE: <code>typing.Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>_T</code> <p>The callback's result.</p> RAISES DESCRIPTION <code>alluka.MissingDependencyError</code> <p>If any of the callback's required type dependencies aren't implemented by the client.</p> <code>alluka.SyncOnlyError</code> <p>If the callback or any of its callback dependencies are async.</p>"},{"location":"reference/abc/#alluka.abc.Undefined","title":"Undefined","text":"<p>Deprecated type of the UNDEFINED constant.</p> <p>deprecated</p> <p>This will be removed in <code>v0.2.0</code>.</p>"}]}