{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Alluka # A type based dependency injection framework for Python 3.9+. Usage # For how to get started with this library, see the documentation . Installation # You can install Alluka from PyPI using the following command in any Python 3.9 or above environment. python -m pip install -U alluka Contributing # Before contributing you should read through the contributing guidelines and the code of conduct .","title":"Home"},{"location":"#alluka","text":"A type based dependency injection framework for Python 3.9+.","title":"Alluka"},{"location":"#usage","text":"For how to get started with this library, see the documentation .","title":"Usage"},{"location":"#installation","text":"You can install Alluka from PyPI using the following command in any Python 3.9 or above environment. python -m pip install -U alluka","title":"Installation"},{"location":"#contributing","text":"Before contributing you should read through the contributing guidelines and the code of conduct .","title":"Contributing"},{"location":"changelog/","text":"Changelog # All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased # 0.1.3 - 2022-11-12 # Added # alluka.abc.Client is now set as a type dependency by default. Changed # Renamed AsyncOnlyError to SyncOnlyError ( AsyncOnlyError has been kept as a deprecated alias). Relaxed typing around DI for async callbacks to allow for returning a union of Coroutine[Any, Any, T] | T . Fixed # Don't error on async callbacks which return a coroutine after being awaited during DI when assertions are enabled. Removed # The project metadata dunder attributes from alluka . importlib.metadata should be used to get this metadata instead. 0.1.2 - 2022-07-06 # Changed # The optional introspect_annotations parameter for alluka.Client.__init__ is now keyword only. tanjun.abc.Client is now a real abc.ABC . Deprecated # alluka.abc.Undefined and alluka.abc.UNDEFINED for removal in v0.2.0 as these will no-longer be used. get_type_dependency and get_cached_result returning UNDEFINED as the default when no default is passed will be replaced by a KeyError raise in v0.2.0 . 0.1.1 - 2022-03-20 # Fixed # Regression around handling of \"signature-less\" builtin functions. A ValueError will no longer be raised in these cases. 0.1.0 - 2022-02-25 # All of the 0.1.0 entries are relative to the feature set exposed while this was a part of Tanjun. Added # Support for synchronous dependency injection (this comes with SyncOnlyError ) Abstract interface for the client with limited functionality. call_with_di and call_with_async_di to alluka.abc.Context as a shorthand for executing a callback with that context. call_with_di , call_with_async_di , call_with_ctx and call_with_ctx_async methods to the injection client for executing callbacks with DI. Support for inferring the type of a parameter from its type hint when no type or callback is explicitly provided. Support for using typing.Annotated to declare parameter DI. This takes two forms: parameter: alluka.Inject[Type] to infer specifically a type dependency. parameter: typing.Annotated(Type, alluka.inject(type=.../callback=...)) . Changed # Passed keyword arguments are now prioritised over dependency injection. Removed # The public CallackDescriptor and TypeDescriptor classes as callbacks are now processed within the client and any necessary caching is kept internal.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#013-2022-11-12","text":"","title":"0.1.3 - 2022-11-12"},{"location":"changelog/#added","text":"alluka.abc.Client is now set as a type dependency by default.","title":"Added"},{"location":"changelog/#changed","text":"Renamed AsyncOnlyError to SyncOnlyError ( AsyncOnlyError has been kept as a deprecated alias). Relaxed typing around DI for async callbacks to allow for returning a union of Coroutine[Any, Any, T] | T .","title":"Changed"},{"location":"changelog/#fixed","text":"Don't error on async callbacks which return a coroutine after being awaited during DI when assertions are enabled.","title":"Fixed"},{"location":"changelog/#removed","text":"The project metadata dunder attributes from alluka . importlib.metadata should be used to get this metadata instead.","title":"Removed"},{"location":"changelog/#012-2022-07-06","text":"","title":"0.1.2 - 2022-07-06"},{"location":"changelog/#changed_1","text":"The optional introspect_annotations parameter for alluka.Client.__init__ is now keyword only. tanjun.abc.Client is now a real abc.ABC .","title":"Changed"},{"location":"changelog/#deprecated","text":"alluka.abc.Undefined and alluka.abc.UNDEFINED for removal in v0.2.0 as these will no-longer be used. get_type_dependency and get_cached_result returning UNDEFINED as the default when no default is passed will be replaced by a KeyError raise in v0.2.0 .","title":"Deprecated"},{"location":"changelog/#011-2022-03-20","text":"","title":"0.1.1 - 2022-03-20"},{"location":"changelog/#fixed_1","text":"Regression around handling of \"signature-less\" builtin functions. A ValueError will no longer be raised in these cases.","title":"Fixed"},{"location":"changelog/#010-2022-02-25","text":"All of the 0.1.0 entries are relative to the feature set exposed while this was a part of Tanjun.","title":"0.1.0 - 2022-02-25"},{"location":"changelog/#added_1","text":"Support for synchronous dependency injection (this comes with SyncOnlyError ) Abstract interface for the client with limited functionality. call_with_di and call_with_async_di to alluka.abc.Context as a shorthand for executing a callback with that context. call_with_di , call_with_async_di , call_with_ctx and call_with_ctx_async methods to the injection client for executing callbacks with DI. Support for inferring the type of a parameter from its type hint when no type or callback is explicitly provided. Support for using typing.Annotated to declare parameter DI. This takes two forms: parameter: alluka.Inject[Type] to infer specifically a type dependency. parameter: typing.Annotated(Type, alluka.inject(type=.../callback=...)) .","title":"Added"},{"location":"changelog/#changed_2","text":"Passed keyword arguments are now prioritised over dependency injection.","title":"Changed"},{"location":"changelog/#removed_1","text":"The public CallackDescriptor and TypeDescriptor classes as callbacks are now processed within the client and any necessary caching is kept internal.","title":"Removed"},{"location":"usage/","text":"Usage # Function injection # This form of dependency injection works by injecting values for keyword arguments during callback execution based on the linked client. This is the main form of dependency injection implemented by Alluka. Declaring a function's injected dependencies # There are two styles for declaring a function's injected dependencies in Alluka: Default descriptors # def callback ( foo : Foo = alluka . inject ( type = Foo ) bar : BarResult = alluka . inject ( callback = bar_callback ) ) -> None : ... Assigning the result of alluka.inject to a parameter's default will declare it as requiring an injected type or callback. async def callback ( foo : Foo = alluka . inject () ) -> None : ... If neither type nor callback is passed to alluka.inject then a type dependency will be inferred from the parameter's annotation. Warning The type-hint will need to resolvable/accessible at runtime in the callback's module for it to be inferred (so it can't be hidden behind a typing.TYPE_CHECKING only import or using a type or operation that isn't implemented in the current python version). Type-hint metadata # typing.Annotated style type-hint descriptors may be used to declare the injected dependencies for a function. def callback ( foo : typing . Annotated [ Foo , alluka . inject ( type = Foo )], bar : typing . Annotated [ BarResult , alluka . inject ( callback = bar_callback )] ) -> None : ... Where passing the default descriptors returned by alluka.inject to typing.Annotated lets you declare the type or callback dependency for an argument without effecting non-DI calls to the function (by leaving these parameters required). async def callback ( foo : alluka . Injected [ Foo ] ) -> None : ... And alluka.Injected provides a shorthand for using typing.Annotated to declare a type dependency. Note alluka.Injected can be safely passed to typing.Annotated as the first type argument or vice versa thanks to how Annotated handles nesting. Calling functions with dependency injection # client : alluka . Client async def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = await client . call_with_async_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with async dependency injection alluka.abc.Client.call_with_async_di should be called with the function and any positional or keyword arguments to pass through alongside the the injected arguments. Note While both sync and async functions may be executed with call_with_async_di , you'll always have to await call_with_async_di to get the result of the call. client : alluka . Client def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = client . call_with_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with purely sync dependency injection alluka.abc.Client.call_with_di can be used with similar semantics to call_with_async_di for passed through arguments but this comes with the limitation that only sync functions may be used and any dependency on async callback dependencies will lead to alluka.SyncOnlyError being raised. def foo ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = ctx . call_with_di ( other_callback , 542 , keyword_arg = \"meow\" ) Alternatively, alluka.abc.Context.call_with_di and alluka.abc.Context.call_with_async_di can be used to execute functions with dependency injection while preserving the current injection context. async def bar ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = await ctx . call_with_async_di ( other_callback , 123 , keyword_arg = \"ok\" ) Using the client # Adding type dependencies # client = ( alluka . Client () . set_type_dependency ( TypeA , type_a_impl ) . set_type_dependencu ( TypeB , type_b_impl ) ) For a type dependency to work, the linked client will have to have an implementation loaded for it. While right now the only way to load type dependencies is with the lower-level alluka.abc.Client.set_type_dependency method, more approaches and helpers will be added in the future as Alluka is further developed. Overriding callback dependencies # client = alluka . Client () . set_callback_override ( callback , other_callback ) While (unlike type dependencies) callback dependencies can work on their own without being explicitly declared on the client unless they're relying on a type dependency themselves, they can still be overridden on a client level using alluka.abc.Client.set_callback_override . Generally speaking you should only ever override an injected callback with a callback which returns a compatible type but their signatures do not need to match and async callbacks can be overridden with sync with vice versa also working (although the latter will prevent callbacks from being used in an async context).","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#function-injection","text":"This form of dependency injection works by injecting values for keyword arguments during callback execution based on the linked client. This is the main form of dependency injection implemented by Alluka.","title":"Function injection"},{"location":"usage/#declaring-a-functions-injected-dependencies","text":"There are two styles for declaring a function's injected dependencies in Alluka:","title":"Declaring a function's injected dependencies"},{"location":"usage/#default-descriptors","text":"def callback ( foo : Foo = alluka . inject ( type = Foo ) bar : BarResult = alluka . inject ( callback = bar_callback ) ) -> None : ... Assigning the result of alluka.inject to a parameter's default will declare it as requiring an injected type or callback. async def callback ( foo : Foo = alluka . inject () ) -> None : ... If neither type nor callback is passed to alluka.inject then a type dependency will be inferred from the parameter's annotation. Warning The type-hint will need to resolvable/accessible at runtime in the callback's module for it to be inferred (so it can't be hidden behind a typing.TYPE_CHECKING only import or using a type or operation that isn't implemented in the current python version).","title":"Default descriptors"},{"location":"usage/#type-hint-metadata","text":"typing.Annotated style type-hint descriptors may be used to declare the injected dependencies for a function. def callback ( foo : typing . Annotated [ Foo , alluka . inject ( type = Foo )], bar : typing . Annotated [ BarResult , alluka . inject ( callback = bar_callback )] ) -> None : ... Where passing the default descriptors returned by alluka.inject to typing.Annotated lets you declare the type or callback dependency for an argument without effecting non-DI calls to the function (by leaving these parameters required). async def callback ( foo : alluka . Injected [ Foo ] ) -> None : ... And alluka.Injected provides a shorthand for using typing.Annotated to declare a type dependency. Note alluka.Injected can be safely passed to typing.Annotated as the first type argument or vice versa thanks to how Annotated handles nesting.","title":"Type-hint metadata"},{"location":"usage/#calling-functions-with-dependency-injection","text":"client : alluka . Client async def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = await client . call_with_async_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with async dependency injection alluka.abc.Client.call_with_async_di should be called with the function and any positional or keyword arguments to pass through alongside the the injected arguments. Note While both sync and async functions may be executed with call_with_async_di , you'll always have to await call_with_async_di to get the result of the call. client : alluka . Client def callback ( argument : int , / , injected : alluka . Injected [ Foo ], keyword_arg : str , ) -> int : ... ... result = client . call_with_di ( callback , 123 , keyword_arg = \"ok\" ) To execute a function with purely sync dependency injection alluka.abc.Client.call_with_di can be used with similar semantics to call_with_async_di for passed through arguments but this comes with the limitation that only sync functions may be used and any dependency on async callback dependencies will lead to alluka.SyncOnlyError being raised. def foo ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = ctx . call_with_di ( other_callback , 542 , keyword_arg = \"meow\" ) Alternatively, alluka.abc.Context.call_with_di and alluka.abc.Context.call_with_async_di can be used to execute functions with dependency injection while preserving the current injection context. async def bar ( ctx : alluka . Inject [ alluka . abc . Context ]) -> None : result = await ctx . call_with_async_di ( other_callback , 123 , keyword_arg = \"ok\" )","title":"Calling functions with dependency injection"},{"location":"usage/#using-the-client","text":"","title":"Using the client"},{"location":"usage/#adding-type-dependencies","text":"client = ( alluka . Client () . set_type_dependency ( TypeA , type_a_impl ) . set_type_dependencu ( TypeB , type_b_impl ) ) For a type dependency to work, the linked client will have to have an implementation loaded for it. While right now the only way to load type dependencies is with the lower-level alluka.abc.Client.set_type_dependency method, more approaches and helpers will be added in the future as Alluka is further developed.","title":"Adding type dependencies"},{"location":"usage/#overriding-callback-dependencies","text":"client = alluka . Client () . set_callback_override ( callback , other_callback ) While (unlike type dependencies) callback dependencies can work on their own without being explicitly declared on the client unless they're relying on a type dependency themselves, they can still be overridden on a client level using alluka.abc.Client.set_callback_override . Generally speaking you should only ever override an injected callback with a callback which returns a compatible type but their signatures do not need to match and async callbacks can be overridden with sync with vice versa also working (although the latter will prevent callbacks from being used in an async context).","title":"Overriding callback dependencies"},{"location":"reference/","text":"alluka # A type based dependency injection framework for Python 3.9+. Injected module-attribute # Injected = typing . Annotated [ _T , InjectedTypes . TYPE ] Type alias used to declare a keyword argument as requiring an injected type. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. Note This is a typing.Annotated alias and the behaviour for nested Annotated types may be found at the docs for it typing.Annotated . AllukaError # Bases: Exception Base class for the custom errors raised by Alluka. AsyncSelfInjecting # Bases: alluka . AsyncSelfInjecting [ _CallbackSigT ] Class used to link a sync function to a client to make it self-injecting. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . AsyncSelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_async_self_injecting may be used: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __init__ # __init__ ( client , callback ) Initialise a self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: alluka . Client callback The callback to make self-injecting. This may be sync or async. TYPE: alluka . abc . CallbackSig RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally. BasicContext # Bases: alluka . Context Basic implementation of alluka.abc.Context . __init__ # __init__ ( client ) Initialise a basic injection context. PARAMETER DESCRIPTION client The injection client this context is bound to. TYPE: alluka . Client Client # Bases: alluka . Client Standard implementation of a dependency injection client. This is used to track type dependencies and execute callbacks. __init__ # __init__ ( * , introspect_annotations = True ) Initialise an injector client. InjectedDescriptor # Bases: typing . Generic [ _T ] Descriptor used to a declare keyword-argument as requiring an injected dependency. This is the type returned by alluka.inject . __init__ # __init__ ( * , callback = None , type = None ) Initialise an injection default descriptor. Note If neither type or callback is provided, an injected type will be inferred from the argument's annotation. PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ alluka . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately after the litarl union type is tried, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Optional [ _TypeT [ _T ]] DEFAULT: None RAISES DESCRIPTION ValueError If both callback and type are provided. MissingDependencyError # Bases: AllukaError Error raised when a dependency couldn't be found. __init__ # __init__ ( message , dependency_type ) Initialise a missing dependency error. PARAMETER DESCRIPTION message The error message. TYPE: str SelfInjecting # Bases: alluka . SelfInjecting [ _SyncCallbackT ] Class used to link a sync function to a client to make it self-injecting. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . SelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_self_injecting may be used: client = alluka . Client () @client . as_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __init__ # __init__ ( client , callback ) Initialise a sync self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: alluka . Client callback The callback to make self-injecting. TYPE: collections . abc . Callable RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally. SyncOnlyError # Bases: AllukaError Error raised when trying to execute async DI in a sync context. inject # inject ( * , callback = None , type = None ) Decare a keyword-argument as requiring an injected dependency. This may be assigned to an arugment's default value to declare injection or as a part of its Annotated metadata. Note If neither type nor callback is provided, an injected type will be inferred from the argument's annotation. Examples: async def callback ( # Here we require an implementation of the type `Component` to be # injected. injected_type : Component = alluka . inject ( type = Component ) # Here we inject an out-of-scope callback which itself is taking # advantage of type injectioallukan. callback_result : ResultT = alluka . inject ( callback = injected_callback ) ) -> None : raise NotImplementedError ... # where client is an `alluka.Client` instance. result = await client . call_with_async_di ( callback ) PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ alluka . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Any DEFAULT: None RAISES DESCRIPTION ValueError If both type and callback are provided.","title":"alluka"},{"location":"reference/#alluka_1","text":"A type based dependency injection framework for Python 3.9+.","title":"alluka"},{"location":"reference/#alluka.Injected","text":"Injected = typing . Annotated [ _T , InjectedTypes . TYPE ] Type alias used to declare a keyword argument as requiring an injected type. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. Note This is a typing.Annotated alias and the behaviour for nested Annotated types may be found at the docs for it typing.Annotated .","title":"Injected"},{"location":"reference/#alluka.AllukaError","text":"Bases: Exception Base class for the custom errors raised by Alluka.","title":"AllukaError"},{"location":"reference/#alluka.AsyncSelfInjecting","text":"Bases: alluka . AsyncSelfInjecting [ _CallbackSigT ] Class used to link a sync function to a client to make it self-injecting. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . AsyncSelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_async_self_injecting may be used: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"AsyncSelfInjecting"},{"location":"reference/#alluka._self_injecting.AsyncSelfInjecting.__init__","text":"__init__ ( client , callback ) Initialise a self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: alluka . Client callback The callback to make self-injecting. This may be sync or async. TYPE: alluka . abc . CallbackSig RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally.","title":"__init__()"},{"location":"reference/#alluka.BasicContext","text":"Bases: alluka . Context Basic implementation of alluka.abc.Context .","title":"BasicContext"},{"location":"reference/#alluka._client.BasicContext.__init__","text":"__init__ ( client ) Initialise a basic injection context. PARAMETER DESCRIPTION client The injection client this context is bound to. TYPE: alluka . Client","title":"__init__()"},{"location":"reference/#alluka.Client","text":"Bases: alluka . Client Standard implementation of a dependency injection client. This is used to track type dependencies and execute callbacks.","title":"Client"},{"location":"reference/#alluka._client.Client.__init__","text":"__init__ ( * , introspect_annotations = True ) Initialise an injector client.","title":"__init__()"},{"location":"reference/#alluka.InjectedDescriptor","text":"Bases: typing . Generic [ _T ] Descriptor used to a declare keyword-argument as requiring an injected dependency. This is the type returned by alluka.inject .","title":"InjectedDescriptor"},{"location":"reference/#alluka._types.InjectedDescriptor.__init__","text":"__init__ ( * , callback = None , type = None ) Initialise an injection default descriptor. Note If neither type or callback is provided, an injected type will be inferred from the argument's annotation. PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ alluka . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately after the litarl union type is tried, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Optional [ _TypeT [ _T ]] DEFAULT: None RAISES DESCRIPTION ValueError If both callback and type are provided.","title":"__init__()"},{"location":"reference/#alluka.MissingDependencyError","text":"Bases: AllukaError Error raised when a dependency couldn't be found.","title":"MissingDependencyError"},{"location":"reference/#alluka._errors.MissingDependencyError.__init__","text":"__init__ ( message , dependency_type ) Initialise a missing dependency error. PARAMETER DESCRIPTION message The error message. TYPE: str","title":"__init__()"},{"location":"reference/#alluka.SelfInjecting","text":"Bases: alluka . SelfInjecting [ _SyncCallbackT ] Class used to link a sync function to a client to make it self-injecting. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: async def callback ( database : Database = alluka . inject ( type = Database )) -> None : await database . do_something () ... client = alluka . Client () injecting_callback = alluka . SelfInjecting ( callback , client ) await injecting_callback () Alternatively alluka.abc.Client.as_self_injecting may be used: client = alluka . Client () @client . as_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"SelfInjecting"},{"location":"reference/#alluka._self_injecting.SelfInjecting.__init__","text":"__init__ ( client , callback ) Initialise a sync self injecting callback. PARAMETER DESCRIPTION client The injection client to use to resolve dependencies. TYPE: alluka . Client callback The callback to make self-injecting. TYPE: collections . abc . Callable RAISES DESCRIPTION ValueError If callback has any injected arguments which can only be passed positionally.","title":"__init__()"},{"location":"reference/#alluka.SyncOnlyError","text":"Bases: AllukaError Error raised when trying to execute async DI in a sync context.","title":"SyncOnlyError"},{"location":"reference/#alluka.inject","text":"inject ( * , callback = None , type = None ) Decare a keyword-argument as requiring an injected dependency. This may be assigned to an arugment's default value to declare injection or as a part of its Annotated metadata. Note If neither type nor callback is provided, an injected type will be inferred from the argument's annotation. Examples: async def callback ( # Here we require an implementation of the type `Component` to be # injected. injected_type : Component = alluka . inject ( type = Component ) # Here we inject an out-of-scope callback which itself is taking # advantage of type injectioallukan. callback_result : ResultT = alluka . inject ( callback = injected_callback ) ) -> None : raise NotImplementedError ... # where client is an `alluka.Client` instance. result = await client . call_with_async_di ( callback ) PARAMETER DESCRIPTION callback The callback to use to resolve the dependency. If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override . TYPE: typing . Optional [ alluka . CallbackSig [ _T ]] DEFAULT: None type The type of the dependency to resolve. If a union (e.g. typing.Union[A, B] , A | B , typing.Optional[A] ) is passed for type then each type in the union will be tried separately rather than the literal type, allowing for resolving A | B to the value set by set_type_dependency(B, ...) . If a union has None as one of its types (including Optional[T] ) then None will be passed for the parameter if none of the types could be resolved using the linked client. TYPE: typing . Any DEFAULT: None RAISES DESCRIPTION ValueError If both type and callback are provided.","title":"inject()"},{"location":"reference/abc/","text":"alluka.abc # Alluka's abstract interfaces. CallbackSig module-attribute # CallbackSig = collections . Callable [ Ellipsis , typing . Union [ _CoroT [ _T ], _T ]] Type-hint of a injector callback. Note Dependency dependency injection is recursively supported, meaning that the keyword arguments for a dependency callback may also ask for dependencies themselves. This may either be a sync or asyc function with dependency injection being available for the callback's keyword arguments but dynamically returning either a coroutine or raw value may lead to errors. Dependent on the context positional arguments may also be proivded. UNDEFINED module-attribute # UNDEFINED : typing . Final [ Undefined ] = Undefined () Deprecated singleton value used to indicate that a value is undefined deprecated This will be removedin v0.2.0 . AsyncSelfInjecting # Bases: abc . ABC , typing . Generic [ _CallbackT ] Interface of a class used to make an async self-injecting callback. Examples: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __call__ abstractmethod async # __call__ ( * args , ** kwargs ) Call this with the provided arguments and any injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback alongside injected arguments. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. callback abstractmethod property # callback () The callback this wraps. Client # Bases: abc . ABC Abstract interface of a dependency injection client. as_async_self_injecting abstractmethod # as_async_self_injecting ( callback ) Link a function to a client to make it self-injecting. PARAMETER DESCRIPTION callback The callback to make self-injecting. This may be sync or async. TYPE: CallbackSig RETURNS DESCRIPTION AsyncSelfInjecting The async self-injecting callback. as_self_injecting abstractmethod # as_self_injecting ( callback ) Link a sync function to a client to make it self-injecting. Note This uses sync dependency injection and therefore will lead to errors if any of the callback's dependencies are async. PARAMETER DESCRIPTION callback The callback to make self-injecting. This must be sync. TYPE: collections . abc . Callable RETURNS DESCRIPTION SelfInjecting The self-injecting callback. call_with_async_di abstractmethod async # call_with_async_di ( callback , * args , ** kwargs ) Call a function with async dependency injection. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async. call_with_ctx abstractmethod # call_with_ctx ( ctx , callback , * args , ** kwargs ) Call a function with an existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async. call_with_ctx_async abstractmethod async # call_with_ctx_async ( ctx , callback , * args , ** kwargs ) Asynchronously call a function with a pre-existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. call_with_di abstractmethod # call_with_di ( callback , * args , ** kwargs ) Call a function with sync dependency injection. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async. get_callback_override abstractmethod # get_callback_override ( callback ) Get the override for a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to get the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION CallbackSig [ _T ] | None The override if found, else None . get_type_dependency abstractmethod # get_type_dependency ( type_ , / , * , default = UNDEFINED ) Get the implementation for an injected type. deprecated Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in v0.2.0 . PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] default The default value to return if the type is not implemented. TYPE: _UndefinedOr [ _DefaultT ] DEFAULT: UNDEFINED RETURNS DESCRIPTION _T | _DefaultT | alluka . abc . UNDEFINED The resolved type if found. If the type isn't implemented then the value of default will be returned if it is provided, else alluka.abc.UNDEFINED . remove_callback_override abstractmethod # remove_callback_override ( callback ) Remove a callback override. PARAMETER DESCRIPTION callback The injected callback to remove the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If no override is found for the callback. remove_type_dependency abstractmethod # remove_type_dependency ( type_ ) Remove a type dependency. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ typing . Any ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If type is not registered. set_callback_override abstractmethod # set_callback_override ( callback , override ) Override a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to override. TYPE: CallbackSig [ _T ] override The callback to use instead. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining. set_type_dependency abstractmethod # set_type_dependency ( type_ , value ) Set a callback to be called to resolve a injected type. PARAMETER DESCRIPTION type_ The type of the dependency to add an implementation for. TYPE: type [ _T ] value The value of the dependency. TYPE: _T RETURNS DESCRIPTION Self The client instance to allow chaining. Context # Bases: abc . ABC Abstract interface of an injection context. cache_result abstractmethod # cache_result ( callback , value ) Cache the result of a callback within the scope of this context. PARAMETER DESCRIPTION callback The callback to cache the result of. TYPE: CallbackSig [ _T ] value The value to cache. TYPE: _T call_with_async_di abstractmethod async # call_with_async_di ( callback , * args , ** kwargs ) Asynchronously call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. call_with_di abstractmethod # call_with_di ( callback , * args , ** kwargs ) Call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async. get_cached_result abstractmethod # get_cached_result ( callback , / , * , default = UNDEFINED ) Get the cached result of a callback. deprecated Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in v0.2.0 . PARAMETER DESCRIPTION callback The callback to get the cached result of. TYPE: CallbackSig [ _T ] default The default value to return if the callback is not cached. TYPE: _UndefinedOr [ _DefaultT ] DEFAULT: UNDEFINED RETURNS DESCRIPTION _T | _DefaultT | alluka . abc . UNDEFINED The cached result of the callback if found. If the callback's result hasn't been cached or caching isn't implementing then this will return the value of default if it is provided, else alluka.abc.UNDEFINED . get_type_dependency abstractmethod # get_type_dependency ( type_ , / , * , default = UNDEFINED ) Get the implementation for an injected type. Unlike Client.get_type_dependency , this method may also return context specific implementations of a type. deprecated Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in v0.2.0 . PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] default The default value to return if the type is not implemented. TYPE: _UndefinedOr [ _DefaultT ] DEFAULT: UNDEFINED RETURNS DESCRIPTION _T | _DefaultT | alluka . abc . UNDEFINED The resolved type if found. If the type isn't implemented then the value of default will be returned if it is provided, else alluka.abc.UNDEFINED . injection_client abstractmethod property # injection_client () Injection client this context is bound to. SelfInjecting # Bases: abc . ABC , typing . Generic [ _SyncCallbackT ] Interface of a class used to make a self-injecting callback. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: client = alluka . Client () @client . as_self_injecting def callback ( database : Database = alluka . inject ( type = Database )) -> None : ... __call__ abstractmethod # __call__ ( * args , ** kwargs ) Call this callback with the provided arguments + injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async. callback abstractmethod property # callback () The callback this wraps. Undefined # Deprecated type of the UNDEFINED constant. deprecated This will be removed in v0.2.0 .","title":"alluka.abc"},{"location":"reference/abc/#allukaabc","text":"Alluka's abstract interfaces.","title":"alluka.abc"},{"location":"reference/abc/#alluka.abc.CallbackSig","text":"CallbackSig = collections . Callable [ Ellipsis , typing . Union [ _CoroT [ _T ], _T ]] Type-hint of a injector callback. Note Dependency dependency injection is recursively supported, meaning that the keyword arguments for a dependency callback may also ask for dependencies themselves. This may either be a sync or asyc function with dependency injection being available for the callback's keyword arguments but dynamically returning either a coroutine or raw value may lead to errors. Dependent on the context positional arguments may also be proivded.","title":"CallbackSig"},{"location":"reference/abc/#alluka.abc.UNDEFINED","text":"UNDEFINED : typing . Final [ Undefined ] = Undefined () Deprecated singleton value used to indicate that a value is undefined deprecated This will be removedin v0.2.0 .","title":"UNDEFINED"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting","text":"Bases: abc . ABC , typing . Generic [ _CallbackT ] Interface of a class used to make an async self-injecting callback. Examples: client = alluka . Client () @client . as_async_self_injecting async def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"AsyncSelfInjecting"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.__call__","text":"__call__ ( * args , ** kwargs ) Call this with the provided arguments and any injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback alongside injected arguments. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client.","title":"__call__()"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.callback","text":"callback () The callback this wraps.","title":"callback()"},{"location":"reference/abc/#alluka.abc.Client","text":"Bases: abc . ABC Abstract interface of a dependency injection client.","title":"Client"},{"location":"reference/abc/#alluka.abc.Client.as_async_self_injecting","text":"as_async_self_injecting ( callback ) Link a function to a client to make it self-injecting. PARAMETER DESCRIPTION callback The callback to make self-injecting. This may be sync or async. TYPE: CallbackSig RETURNS DESCRIPTION AsyncSelfInjecting The async self-injecting callback.","title":"as_async_self_injecting()"},{"location":"reference/abc/#alluka.abc.Client.as_self_injecting","text":"as_self_injecting ( callback ) Link a sync function to a client to make it self-injecting. Note This uses sync dependency injection and therefore will lead to errors if any of the callback's dependencies are async. PARAMETER DESCRIPTION callback The callback to make self-injecting. This must be sync. TYPE: collections . abc . Callable RETURNS DESCRIPTION SelfInjecting The self-injecting callback.","title":"as_self_injecting()"},{"location":"reference/abc/#alluka.abc.Client.call_with_async_di","text":"call_with_async_di ( callback , * args , ** kwargs ) Call a function with async dependency injection. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_async_di()"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx","text":"call_with_ctx ( ctx , callback , * args , ** kwargs ) Call a function with an existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_ctx()"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx_async","text":"call_with_ctx_async ( ctx , callback , * args , ** kwargs ) Asynchronously call a function with a pre-existing DI context. PARAMETER DESCRIPTION ctx The DI context to call the callback with. This will be used for scoped type injection. TYPE: Context callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client.","title":"call_with_ctx_async()"},{"location":"reference/abc/#alluka.abc.Client.call_with_di","text":"call_with_di ( callback , * args , ** kwargs ) Call a function with sync dependency injection. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_di()"},{"location":"reference/abc/#alluka.abc.Client.get_callback_override","text":"get_callback_override ( callback ) Get the override for a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to get the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION CallbackSig [ _T ] | None The override if found, else None .","title":"get_callback_override()"},{"location":"reference/abc/#alluka.abc.Client.get_type_dependency","text":"get_type_dependency ( type_ , / , * , default = UNDEFINED ) Get the implementation for an injected type. deprecated Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in v0.2.0 . PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] default The default value to return if the type is not implemented. TYPE: _UndefinedOr [ _DefaultT ] DEFAULT: UNDEFINED RETURNS DESCRIPTION _T | _DefaultT | alluka . abc . UNDEFINED The resolved type if found. If the type isn't implemented then the value of default will be returned if it is provided, else alluka.abc.UNDEFINED .","title":"get_type_dependency()"},{"location":"reference/abc/#alluka.abc.Client.remove_callback_override","text":"remove_callback_override ( callback ) Remove a callback override. PARAMETER DESCRIPTION callback The injected callback to remove the override for. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If no override is found for the callback.","title":"remove_callback_override()"},{"location":"reference/abc/#alluka.abc.Client.remove_type_dependency","text":"remove_type_dependency ( type_ ) Remove a type dependency. PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ typing . Any ] RETURNS DESCRIPTION Self The client instance to allow chaining. RAISES DESCRIPTION KeyError If type is not registered.","title":"remove_type_dependency()"},{"location":"reference/abc/#alluka.abc.Client.set_callback_override","text":"set_callback_override ( callback , override ) Override a specific injected callback. PARAMETER DESCRIPTION callback The injected callback to override. TYPE: CallbackSig [ _T ] override The callback to use instead. TYPE: CallbackSig [ _T ] RETURNS DESCRIPTION Self The client instance to allow chaining.","title":"set_callback_override()"},{"location":"reference/abc/#alluka.abc.Client.set_type_dependency","text":"set_type_dependency ( type_ , value ) Set a callback to be called to resolve a injected type. PARAMETER DESCRIPTION type_ The type of the dependency to add an implementation for. TYPE: type [ _T ] value The value of the dependency. TYPE: _T RETURNS DESCRIPTION Self The client instance to allow chaining.","title":"set_type_dependency()"},{"location":"reference/abc/#alluka.abc.Context","text":"Bases: abc . ABC Abstract interface of an injection context.","title":"Context"},{"location":"reference/abc/#alluka.abc.Context.cache_result","text":"cache_result ( callback , value ) Cache the result of a callback within the scope of this context. PARAMETER DESCRIPTION callback The callback to cache the result of. TYPE: CallbackSig [ _T ] value The value to cache. TYPE: _T","title":"cache_result()"},{"location":"reference/abc/#alluka.abc.Context.call_with_async_di","text":"call_with_async_di ( callback , * args , ** kwargs ) Asynchronously call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This may be sync or async. TYPE: CallbackSig [ _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client.","title":"call_with_async_di()"},{"location":"reference/abc/#alluka.abc.Context.call_with_di","text":"call_with_di ( callback , * args , ** kwargs ) Call a function with the current DI context. PARAMETER DESCRIPTION callback The callback to call. This must be sync. TYPE: collections . Callable [..., _T ] *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The result of the callback. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async.","title":"call_with_di()"},{"location":"reference/abc/#alluka.abc.Context.get_cached_result","text":"get_cached_result ( callback , / , * , default = UNDEFINED ) Get the cached result of a callback. deprecated Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in v0.2.0 . PARAMETER DESCRIPTION callback The callback to get the cached result of. TYPE: CallbackSig [ _T ] default The default value to return if the callback is not cached. TYPE: _UndefinedOr [ _DefaultT ] DEFAULT: UNDEFINED RETURNS DESCRIPTION _T | _DefaultT | alluka . abc . UNDEFINED The cached result of the callback if found. If the callback's result hasn't been cached or caching isn't implementing then this will return the value of default if it is provided, else alluka.abc.UNDEFINED .","title":"get_cached_result()"},{"location":"reference/abc/#alluka.abc.Context.get_type_dependency","text":"get_type_dependency ( type_ , / , * , default = UNDEFINED ) Get the implementation for an injected type. Unlike Client.get_type_dependency , this method may also return context specific implementations of a type. deprecated Defaulting to alluka.abc.UNDEFINED is deprecated and will be replaced by a KeyError raise in v0.2.0 . PARAMETER DESCRIPTION type_ The associated type. TYPE: type [ _T ] default The default value to return if the type is not implemented. TYPE: _UndefinedOr [ _DefaultT ] DEFAULT: UNDEFINED RETURNS DESCRIPTION _T | _DefaultT | alluka . abc . UNDEFINED The resolved type if found. If the type isn't implemented then the value of default will be returned if it is provided, else alluka.abc.UNDEFINED .","title":"get_type_dependency()"},{"location":"reference/abc/#alluka.abc.Context.injection_client","text":"injection_client () Injection client this context is bound to.","title":"injection_client()"},{"location":"reference/abc/#alluka.abc.SelfInjecting","text":"Bases: abc . ABC , typing . Generic [ _SyncCallbackT ] Interface of a class used to make a self-injecting callback. Note This executes the callback synchronously and therefore will error if any of the callback's dependencies are async. Examples: client = alluka . Client () @client . as_self_injecting def callback ( database : Database = alluka . inject ( type = Database )) -> None : ...","title":"SelfInjecting"},{"location":"reference/abc/#alluka.abc.SelfInjecting.__call__","text":"__call__ ( * args , ** kwargs ) Call this callback with the provided arguments + injected arguments. PARAMETER DESCRIPTION *args Positional arguments to pass to the callback. TYPE: typing . Any DEFAULT: () **kwargs Keyword arguments to pass to the callback. TYPE: typing . Any DEFAULT: {} RETURNS DESCRIPTION _T The callback's result. RAISES DESCRIPTION alluka . MissingDependencyError If any of the callback's required type dependencies aren't implemented by the client. alluka . SyncOnlyError If the callback or any of its callback dependencies are async.","title":"__call__()"},{"location":"reference/abc/#alluka.abc.SelfInjecting.callback","text":"callback () The callback this wraps.","title":"callback()"},{"location":"reference/abc/#alluka.abc.Undefined","text":"Deprecated type of the UNDEFINED constant. deprecated This will be removed in v0.2.0 .","title":"Undefined"}]}